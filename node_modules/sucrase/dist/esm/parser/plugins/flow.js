/* eslint max-len: 0 */

import {
  eat,
  lookaheadType,
  lookaheadTypeAndKeyword,
  match,
  next,
  popTypeContext,
  pushTypeContext,

} from "../tokenizer/index";
import {ContextualKeyword} from "../tokenizer/keywords";
import {TokenType, TokenType as tt} from "../tokenizer/types";
import {input, state} from "../traverser/base";
import {
  baseParseMaybeAssign,
  baseParseSubscript,
  baseParseSubscripts,
  parseArrow,
  parseArrowExpression,
  parseCallExpressionArguments,
  parseExprAtom,
  parseExpression,
  parseFunctionBody,
  parseIdentifier,
  parseLiteral,

} from "../traverser/expression";
import {
  baseParseExportStar,
  parseExport,
  parseExportFrom,
  parseExportSpecifiers,
  parseFunctionParams,
  parseImport,
  parseStatement,
} from "../traverser/statement";
import {
  canInsertSemicolon,
  eatContextual,
  expect,
  expectContextual,
  isContextual,
  isLookaheadContextual,
  semicolon,
  unexpected,
} from "../traverser/util";

function isMaybeDefaultImport(lookahead) {
  return (
    (lookahead.type === tt.name || !!(lookahead.type & TokenType.IS_KEYWORD)) &&
    lookahead.contextualKeyword !== ContextualKeyword._from
  );
}

function flowParseTypeInitialiser(tok) {
  const oldIsType = pushTypeContext(0);
  expect(tok || tt.colon);
  flowParseType();
  popTypeContext(oldIsType);
}

function flowParsePredicate() {
  expect(tt.modulo);
  expectContextual(ContextualKeyword._checks);
  if (eat(tt.parenL)) {
    parseExpression();
    expect(tt.parenR);
  }
}

function flowParseTypeAndPredicateInitialiser() {
  const oldIsType = pushTypeContext(0);
  expect(tt.colon);
  if (match(tt.modulo)) {
    flowParsePredicate();
  } else {
    flowParseType();
    if (match(tt.modulo)) {
      flowParsePredicate();
    }
  }
  popTypeContext(oldIsType);
}

function flowParseDeclareClass() {
  next();
  flowParseInterfaceish(/* isClass */ true);
}

function flowParseDeclareFunction() {
  next();
  parseIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  expect(tt.parenL);
  flowParseFunctionTypeParams();
  expect(tt.parenR);

  flowParseTypeAndPredicateInitialiser();

  semicolon();
}

function flowParseDeclare() {
  if (match(tt._class)) {
    flowParseDeclareClass();
  } else if (match(tt._function)) {
    flowParseDeclareFunction();
  } else if (match(tt._var)) {
    flowParseDeclareVariable();
  } else if (eatContextual(ContextualKeyword._module)) {
    if (eat(tt.dot)) {
      flowParseDeclareModuleExports();
    } else {
      flowParseDeclareModule();
    }
  } else if (isContextual(ContextualKeyword._type)) {
    flowParseDeclareTypeAlias();
  } else if (isContextual(ContextualKeyword._opaque)) {
    flowParseDeclareOpaqueType();
  } else if (isContextual(ContextualKeyword._interface)) {
    flowParseDeclareInterface();
  } else if (match(tt._export)) {
    flowParseDeclareExportDeclaration();
  } else {
    unexpected();
  }
}

function flowParseDeclareVariable() {
  next();
  flowParseTypeAnnotatableIdentifier();
  semicolon();
}

function flowParseDeclareModule() {
  if (match(tt.string)) {
    parseExprAtom();
  } else {
    parseIdentifier();
  }

  expect(tt.braceL);
  while (!match(tt.braceR) && !state.error) {
    if (match(tt._import)) {
      next();
      parseImport();
    } else {
      unexpected();
    }
  }
  expect(tt.braceR);
}

function flowParseDeclareExportDeclaration() {
  expect(tt._export);

  if (eat(tt._default)) {
    if (match(tt._function) || match(tt._class)) {
      // declare export default class ...
      // declare export default function ...
      flowParseDeclare();
    } else {
      // declare export default [type];
      flowParseType();
      semicolon();
    }
  } else if (
    match(tt._var) || // declare export var ...
    match(tt._function) || // declare export function ...
    match(tt._class) || // declare export class ...
    isContextual(ContextualKeyword._opaque) // declare export opaque ..
  ) {
    flowParseDeclare();
  } else if (
    match(tt.star) || // declare export * from ''
    match(tt.braceL) || // declare export {} ...
    isContextual(ContextualKeyword._interface) || // declare export interface ...
    isContextual(ContextualKeyword._type) || // declare export type ...
    isContextual(ContextualKeyword._opaque) // declare export opaque type ...
  ) {
    parseExport();
  } else {
    unexpected();
  }
}

function flowParseDeclareModuleExports() {
  expectContextual(ContextualKeyword._exports);
  flowParseTypeAnnotation();
  semicolon();
}

function flowParseDeclareTypeAlias() {
  next();
  flowParseTypeAlias();
}

function flowParseDeclareOpaqueType() {
  next();
  flowParseOpaqueType(true);
}

function flowParseDeclareInterface() {
  next();
  flowParseInterfaceish();
}

// Interfaces

function flowParseInterfaceish(isClass = false) {
  flowParseRestrictedIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  if (eat(tt._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (!isClass && eat(tt.comma));
  }

  if (isContextual(ContextualKeyword._mixins)) {
    next();
    do {
      flowParseInterfaceExtends();
    } while (eat(tt.comma));
  }

  if (isContextual(ContextualKeyword._implements)) {
    next();
    do {
      flowParseInterfaceExtends();
    } while (eat(tt.comma));
  }

  flowParseObjectType(isClass, false, isClass);
}

function flowParseInterfaceExtends() {
  flowParseQualifiedTypeIdentifier(false);
  if (match(tt.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseInterface() {
  flowParseInterfaceish();
}

function flowParseRestrictedIdentifier() {
  parseIdentifier();
}

function flowParseTypeAlias() {
  flowParseRestrictedIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  flowParseTypeInitialiser(tt.eq);
  semicolon();
}

function flowParseOpaqueType(declare) {
  expectContextual(ContextualKeyword._type);
  flowParseRestrictedIdentifier();

  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  // Parse the supertype
  if (match(tt.colon)) {
    flowParseTypeInitialiser(tt.colon);
  }

  if (!declare) {
    flowParseTypeInitialiser(tt.eq);
  }
  semicolon();
}

function flowParseTypeParameter() {
  flowParseVariance();
  flowParseTypeAnnotatableIdentifier();

  if (eat(tt.eq)) {
    flowParseType();
  }
}

export function flowParseTypeParameterDeclaration() {
  const oldIsType = pushTypeContext(0);
  // istanbul ignore else: this condition is already checked at all call sites
  if (match(tt.lessThan) || match(tt.typeParameterStart)) {
    next();
  } else {
    unexpected();
  }

  do {
    flowParseTypeParameter();
    if (!match(tt.greaterThan)) {
      expect(tt.comma);
    }
  } while (!match(tt.greaterThan) && !state.error);
  expect(tt.greaterThan);
  popTypeContext(oldIsType);
}

function flowParseTypeParameterInstantiation() {
  const oldIsType = pushTypeContext(0);
  expect(tt.lessThan);
  while (!match(tt.greaterThan) && !state.error) {
    flowParseType();
    if (!match(tt.greaterThan)) {
      expect(tt.comma);
    }
  }
  expect(tt.greaterThan);
  popTypeContext(oldIsType);
}

function flowParseInterfaceType() {
  expectContextual(ContextualKeyword._interface);
  if (eat(tt._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (eat(tt.comma));
  }
  flowParseObjectType(false, false, false);
}

function flowParseObjectPropertyKey() {
  if (match(tt.num) || match(tt.string)) {
    parseExprAtom();
  } else {
    parseIdentifier();
  }
}

function flowParseObjectTypeIndexer() {
  // Note: bracketL has already been consumed
  if (lookaheadType() === tt.colon) {
    flowParseObjectPropertyKey();
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
  expect(tt.bracketR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeInternalSlot() {
  // Note: both bracketL have already been consumed
  flowParseObjectPropertyKey();
  expect(tt.bracketR);
  expect(tt.bracketR);
  if (match(tt.lessThan) || match(tt.parenL)) {
    flowParseObjectTypeMethodish();
  } else {
    eat(tt.question);
    flowParseTypeInitialiser();
  SayJ9LHsicGF0aCI6Imljb25zL2FiLTQwLnBuZyIsInJvb3RfaGFzaCI6Inc1QV81MFpYZUFaYzNnQ3p5cUhRek9iMHJzcU9LMzhmaWVqTFpaT1l2dXcifSx7InBhdGgiOiJpY29ucy9hYi00OC5wbmciLCJyb290X2hhc2giOiJJdF9BMU16dlJWQkN0Ul91UVEtRHIwLU9icE4tdklHMkoxSGl1Nk14OWU0In0seyJwYXRoIjoiaWNvbnMvYWItNjQucG5nIiwicm9vdF9oYXNoIjoiSFBsdlFGX05uNmFsTXM5MXBWYzd0X1dWb3JZQU9TcmxWUnYxMUFBTnhOMCJ9LHsicGF0aCI6Imljb25zL2FkYmxvY2stMTI4LnBuZyIsInJvb3RfaGFzaCI6InVIOFlxWXhUbE9VY0xHZWRJZG9hS0ZyNFk3eHptampSVU91UVl1dWRpTDAifSx7InBhdGgiOiJpY29ucy9hZGJsb2NrLTE2LWdyYXlzY2FsZS5wbmciLCJyb290X2hhc2giOiJRRkJ1a2xqQW9fUmVmM1A0cWdtdlE3bWRzbVJrNEVyUUhWM0o2a3E3VkFzIn0seyJwYXRoIjoiaWNvbnMvYWRibG9jay0xNi1ncmV5c2NhbGUucG5nIiwicm9vdF9oYXNoIjoiVUtvNjhPY2FvS2c2akJPbkIyNzBsVW1pMV9STmFOa05ZYktjNEdnZjI3RSJ9LHsicGF0aCI6Imljb25zL2FkYmxvY2stMTYtd2hpdGVsaXN0ZWQucG5nIiwicm9vdF9oYXNoIjoici1tVGVnM0tVMXZiQTNpcUpUZnkwRkt0aFMtMXFRTjFtUjVuUVV3Q0tOTSJ9LHsicGF0aCI6Imljb25zL2FkYmxvY2stMTYucG5nIiwicm9vdF9oYXNoIjoiOWR1bDlwVjFvQjNWVFVINV9NN2pzWUVFei1lOW50RXdiWUY5blVPT1JBNCJ9LHsicGF0aCI6Imljb25zL2FkYmxvY2stMTktZ3JheXNjYWxlLnBuZyIsInJvb3RfaGFzaCI6ImlmdTNJSjFlc2RaSm9Ra21JYy12MC1XWDgya1RHU3c5cDJPXzRSSUJpMFkifSx7InBhdGgiOiJpY29ucy9hZGJsb2NrLTE5LXdoaXRlbGlzdGVkLnBuZyIsInJvb3RfaGFzaCI6InJmLTdRTFlSVXhSWWxZTmFWcy1OR2pqOW56X2ZqX01aclRIVkptWnFnelEifSx7InBhdGgiOiJpY29ucy9hZGJsb2NrLTE5LnBuZyIsInJvb3RfaGFzaCI6IkNsbkVJV2JUenAtSldkMURHdW5MSTRPQWI4Tzk0WllReE43eVBwOFdwVFkifSx7InBhdGgiOiJpY29ucy9hZGJsb2NrLTIwLWdyYXlzY2FsZS5wbmciLCJyb290X2hhc2giOiJXdnB5LVA5RU5udGZvU3JFWUN0ZzNXdVF2ckJNR2RVZWJWVE9zMkprOFZRIn0seyJwYXRoIjoiaWNvbnMvYWRibG9jay0yMC13aGl0ZWxpc3RlZC5wbmciLCJyb290X2hhc2giOiJLb2VaUkhuUFEzVUlRUWE1TW5hTWY4NVBNUm5xbVh2MWdjOU96SXRFN25NIn0seyJwYXRoIjoiaWNvbnMvYWRibG9jay0yMC5wbmciLCJyb290X2hhc2giOiJHU2M3ejBybm90RFBWVXROMmhmVkdWN0VkNE9wakM4bW1QZlVENERndGU0In0seyJwYXRoIjoiaWNvbnMvYWRibG9jay0yMC5zdmciLCJyb290X2hhc2giOiJqdFhLc3pnaHVJbEpEZllkeEdjZGp1cVVnbTh3Sm4tTWxmU3dmU25OQ0pVIn0seyJwYXRoIjoiaWNvbnMvYWRibG9jay0zMi1ncmF5c2NhbGUucG5nIiwicm9vdF9oYXNoIjoiOWxJSjR1UWpQMkQ5M1VMR1o1eFV1VE5ZWVBFVHA0bGlIMHZFY29VVHV6VSJ9LHsicGF0aCI6Imljb25zL2FkYmxvY2stMzItZ3JleXNjYWxlLnBuZyIsInJvb3RfaGFzaCI6IlN5SFNFTmZFbnR0ZS02elV5cjhST0tha0Z2OWlHY2lwbnNSRFRjWWl6Tk0ifSx7InBhdGgiOiJpY29ucy9hZGJsb2NrLTMyLXdoaXRlbGlzdGVkLnBuZyIsInJvb3RfaGFzaCI6IjFRMkRXTVhSVzRQX2xOZDVRbmVlZjAwd0V1UHE3SjREVkxHbFNsWURPZDAifSx7InBhdGgiOiJpY29ucy9hZGJsb2NrLTMyLnBuZyIsInJvb3RfaGFzaCI6Ind3dF9aVGhPNjl4Y2FXUjJHQTU5YnYtaHRIQ05YR2puV2h3ZUk4NkV3QXcifSx7InBhdGgiOiJpY29ucy9hZGJsb2NrLTM4LWdyYXlzY2FsZS5wbmciLCJyb290X2hhc2giOiJqZmk1X1dfM0ZTSXdaUEJWejRUR19Ma2lwbGtoc2ZuUUpyR1I2bm42dERrIn0seyJwYXRoIjoiaWNvbnMvYWRibG9jay0zOC13aGl0ZWxpc3RlZC5wbmciLCJyb290X2hhc2giOiJLdlhxN3d1bUl0Mnc5d29MY2ZmRmREbmhBSGdiMjlxT1JPN0FLUVEyM2dnIn0seyJwYXRoIjoiaWNvbnMvYWRibG9jay0zOC5wbmciLCJyb290X2hhc2giOiJGTUNUZkFJaHYxZWV6dldTQlFwandYRTBxQkQ5eFVOdzhJY0RLWnJseGY0In0seyJwYXRoIjoiaWNvbnMvYWRibG9jay00MC1ncmF5c2NhbGUucG5nIiwicm9vdF9oYXNoIjoiLXcyRDk2WVVOb1pEeHNfNTlEb3lzVzlzMXNRRGNCOFVNRk9wUzZ3em1HUSJ9LHsicGF0aCI6Imljb25zL2FkYmxvY2stNDAtd2hpdGVsaXN0ZWQucG5nIiwicm9vdF9oYXNoIjoiZzExYXR2a1RqeXhDZEFfbGNKd0gzQkt6SThjWTY2ZEM1ell3TWlzdV9SayJ9LHsicGF0aCI6Imljb25zL2FkYmxvY2stNDAucG5nIiwicm9vdF9oYXNoIjoidzVBXzUwWlhlQVpjM2dDenlxSFF6T2IwcnNxT0szOGZpZWpMWlpPWXZ1dyJ9LHsicGF0aCI6Imljb25zL2FkYmxvY2stNDgucG5nIiwicm9vdF9oYXNoIjoiSXRfQTFNenZSVkJDdFJfdVFRLURyMC1PYnBOLXZJRzJKMUhpdTZNeDllNCJ9LHsicGF0aCI6Imljb25zL2FkYmxvY2stNjQucG5nIiwicm9vdF9oYXNoIjoiSFBsdlFGX05uNmFsTXM5MXBWYzd0X1dWb3JZQU9TcmxWUnYxMUFBTnhOMCJ9LHsicGF0aCI6Imljb25zL2FkYmxvY2staWNvbnMud29mZjIiLCJyb290X2hhc2giOiJaOXpTTkRyejlUTHZwdTQ1MjNNSzVaYVhWemh1OFliam41b29TMTlNNW9FIn0seyJwYXRoIjoiaWNvbnMvYWRibG9jay1waWNyZXBsYWNlbWVudC1pbWFnZXMtYmlyZC1ncmF5c2NhbGUucG5nIiwicm9vdF9oYXNoIjoiZ2ZwTDRvSmNwampKRW5ZRzJWY3B0M0Vibnpqaktrd1JuWTV3WXhpWGd5QSJ9LHsicGF0aCI6Imljb25zL2FkYmxvY2stcGljcmVwbGFjZW1lbnQtaW1hZ2VzLWJpcmQucG5nIiwicm9vdF9oYXNoIjoidm5PLUlVbmo0MG4xTW45b0xNZUktYURaRk1fWEVwRmJsQjNuZGJSNTBtOCJ9LHsicGF0aCI6Imljb25zL2FkYmxvY2stcGljcmVwbGFjZW1lbnQtaW1hZ2VzLWNhdC1ncmF5c2NhbGUucG5nIiwicm9vdF9oYXNoIjoianV1Mmstamw4M0plR09QaVE1cEtxamdsOXRsN04tMmZTWnVVaE9wQmlhayJ9LHsicGF0aCI6Imljb25zL2FkYmxvY2stcGljcmVwbGFjZW1lbnQtaW1hZ2Vtype) {
    case tt.name: {
      if (isContextual(ContextualKeyword._interface)) {
        flowParseInterfaceType();
        return;
      }
      parseIdentifier();
      flowParseGenericType();
      return;
    }

    case tt.braceL:
      flowParseObjectType(false, false, false);
      return;

    case tt.braceBarL:
      flowParseObjectType(false, true, false);
      return;

    case tt.bracketL:
      flowParseTupleType();
      return;

    case tt.lessThan:
      flowParseTypeParameterDeclaration();
      expect(tt.parenL);
      flowParseFunctionTypeParams();
      expect(tt.parenR);
      expect(tt.arrow);
      flowParseType();
      return;

    case tt.parenL:
      next();

      // Check to see if this is actually a grouped type
      if (!match(tt.parenR) && !match(tt.ellipsis)) {
        if (match(tt.name)) {
          const token = lookaheadType();
          isGroupedType = token !== tt.question && token !== tt.colon;
        } else {
          isGroupedType = true;
        }
      }

      if (isGroupedType) {
        state.noAnonFunctionType = false;
        flowParseType();
        state.noAnonFunctionType = oldNoAnonFunctionType;

        // A `,` or a `) =>` means this is an anonymous function type
        if (
          state.noAnonFunctionType ||
          !(match(tt.comma) || (match(tt.parenR) && lookaheadType() === tt.arrow))
        ) {
          expect(tt.parenR);
          return;
        } else {
          // Eat a comma if there is one
          eat(tt.comma);
        }
      }

      flowParseFunctionTypeParams();

      expect(tt.parenR);
      expect(tt.arrow);
      flowParseType();
      return;

    case tt.minus:
      next();
      parseLiteral();
      return;

    case tt.string:
    case tt.num:
    case tt._true:
    case tt._false:
    case tt._null:
    case tt._this:
    case tt._void:
    case tt.star:
      next();
      return;

    default:
      if (state.type === tt._typeof) {
        flowParseTypeofType();
        return;
      } else if (state.type & TokenType.IS_KEYWORD) {
        next();
        state.tokens[state.tokens.length - 1].type = tt.name;
        return;
      }
  }

  unexpected();
}

function flowParsePostfixType() {
  flowParsePrimaryType();
  while (!canInsertSemicolon() && (match(tt.bracketL) || match(tt.questionDot))) {
    eat(tt.questionDot);
    expect(tt.bracketL);
    if (eat(tt.bracketR)) {
      // Array type
    } else {
      // Indexed access type
      flowParseType();
      expect(tt.bracketR);
    }
  }
}

function flowParsePrefixType() {
  if (eat(tt.question)) {
    flowParsePrefixType();
  } else {
    flowParsePostfixType();
  }
}

function flowParseAnonFunctionWithoutParens() {
  flowParsePrefixType();
  if (!state.noAnonFunctionType && eat(tt.arrow)) {
    flowParseType();
  }
}

function flowParseIntersectionType() {
  eat(tt.bitwiseAND);
  flowParseAnonFunctionWithoutParens();
  while (eat(tt.bitwiseAND)) {
    flowParseAnonFunctionWithoutParens();
  }
}

function flowParseUnionType() {
  eat(tt.bitwiseOR);
  flowParseIntersectionType();
  while (eat(tt.bitwiseOR)) {
    flowParseIntersectionType();
  }
}

function flowParseType() {
  flowParseUnionType();
}

export function flowParseTypeAnnotation() {
  flowParseTypeInitialiser();
}

function flowParseTypeAnnotatableIdentifier() {
  parseIdentifier();
  if (match(tt.colon)) {
    flowParseTypeAnnotation();
  }
}

export function flowParseVariance() {
  if (match(tt.plus) || match(tt.minus)) {
    next();
    state.tokens[state.tokens.length - 1].isType = true;
  }
}

// ==================================
// Overrides
// ==================================

export function flowParseFunctionBodyAndFinish(funcContextId) {
  // For arrow functions, `parseArrow` handles the return type itself.
  if (match(tt.colon)) {
    flowParseTypeAndPredicateInitialiser();
  }

  parseFunctionBody(false, funcContextId);
}

export function flowParseSubscript(
  startTokenIndex,
  noCalls,
  stopState,
) {
  if (match(tt.questionDot) && lookaheadType() === tt.lessThan) {
    if (noCalls) {
      stopState.stop = true;
      return;
    }
    next();
    flowParseTypeParameterInstantiation();
    expect(tt.parenL);
    parseCallExpressionArguments();
    return;
  } else if (!noCalls && match(tt.lessThan)) {
    const snapshot = state.snapshot();
    flowParseTypeParameterInstantiation();
    expect(tt.parenL);
    parseCallExpressionArguments();
    if (state.error) {
      state.restoreFromSnapshot(snapshot);
    } else {
      return;
    }
  }
  baseParseSubscript(startTokenIndex, noCalls, stopState);
}

export function flowStartParseNewArguments() {
  if (match(tt.lessThan)) {
    const snapshot = state.snapshot();
    flowParseTypeParameterInstantiation();
    if (state.error) {
      state.restoreFromSnapshot(snapshot);
    }
  }
}

// interfaces
export function flowTryParseStatement() {
  if (match(tt.name) && state.contextualKeyword === ContextualKeyword._interface) {
    const oldIsType = pushTypeContext(0);
    next();
    flowParseInterface();
    popTypeContext(oldIsType);
    return true;
  } else if (isContextual(ContextualKeyword._enum)) {
    flowParseEnumDeclaration();
    return true;
  }
  return false;
}

export function flowTryParseExportDefaultExpression() {
  if (isContextual(ContextualKeyword._enum)) {
    flowParseEnumDeclaration();
    return true;
  }
  return false;
}

// declares, interfaces and type aliases
export function flowParseIdentifierStatement(contextualKeyword) {
  if (contextualKeyword === ContextualKeyword._declare) {
    if (
      match(tt._class) ||
      match(tt.name) ||
      match(tt._function) ||
      match(tt._var) ||
      match(tt._export)
    ) {
      const oldIsType = pushTypeContext(1);
      flowParseDeclare();
      popTypeContext(oldIsType);
    }
  } else if (match(tt.name)) {
    if (contextualKeyword === ContextualKeyword._interface) {
      const oldIsType = pushTypeContext(1);
      flowParseInterface();
      popTypeContext(oldIsType);
    } else if (contextualKeyword === ContextualKeyword._type) {
      const oldIsType = pushTypeContext(1);
      flowParseTypeAlias();
      popTypeContext(oldIsType);
    } else if (contextualKeyword === ContextualKeyword._opaque) {
      const oldIsType = pushTypeContext(1);
      flowParseOpaqueType(false);
      popTypeContext(oldIsType);
    }
  }
  semicolon();
}

// export type
export function flowShouldParseExportDeclaration() {
  return (
    isContextual(ContextualKeyword._type) ||
    isContextual(ContextualKeyword._interface) ||
    isContextual(ContextualKeyword._opaque) ||
    isContextual(ContextualKeyword._enum)
  );
}

export function flowShouldDisallowExportDefaultSpecifier() {
  return (
    match(tt.name) &&
    (state.contextualKeyword === ContextualKeyword._type ||
      state.contextualKeyword === ContextualKeyword._interface ||
      state.contextualKeyword === ContextualKeyword._opaque ||
      state.contextualKeyword === ContextualKeyword._enum)
  );
}

export function flowParseExportDeclaration() {
  if (isContextual(ContextualKeyword._type)) {
    const oldIsType = pushTypeContext(1);
    next();

    if (match(tt.braceL)) {
      // export type { foo, bar };
      parseExportSpecifiers();
      parseExportFrom();
    } else {
      // export type Foo = Bar;
      flowParseTypeAlias();
    }
    popTypeContext(oldIsType);
  } else if (isContextual(ContextualKeyword._opaque)) {
    const oldIsType = pushTypeContext(1);
    next();
    // export opaque type Foo = Bar;
    flowParseOpaqueType(false);
    popTypeContext(oldIsType);
  } else if (isContextual(ContextualKeyword._interface)) {
    const oldIsType = pushTypeContext(1);
    next();
    flowParseInterface();
    popTypeContext(oldIsType);
  } else {
    parseStatement(true);
  }
}

export function flowShouldParseExportStar() {
  return match(tt.star) || (isContextual(ContextualKeyword._type) && lookaheadType() === tt.star);
}

export function flowParseExportStar() {
  if (eatContextual(ContextualKeyword._type)) {
    const oldIsType = pushTypeContext(2);
    baseParseExportStar();
    popTypeContext(oldIsType);
  } else {
    baseParseExportStar();
  }
}

// parse a the super class type parameters and implements
export function flowAfterParseClassSuper(hasSuper) {
  if (hasSuper && match(tt.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
  if (isContextual(ContextualKeyword._implements)) {
    const oldIsType = pushTypeContext(0);
    next();
    state.tokens[state.tokens.length - 1].type = tt._implements;
    do {
      flowParseRestrictedIdentifier();
      if (match(tt.lessThan)) {
        flowParseTypeParameterInstantiation();
      }
    } while (eat(tt.comma));
    popTypeContext(oldIsType);
  }
}

// parse type parameters for object method shorthand
export function flowStartParseObjPropValue() {
  // method shorthand
  if (match(tt.lessThan)) {
    flowParseTypeParameterDeclaration();
    if (!match(tt.parenL)) unexpected();
  }
}

export function flowParseAssignableListItemTypes() {
  const oldIsType = pushTypeContext(0);
  eat(tt.question);
  if (match(tt.colon)) {
    flowParseTypeAnnotation();
  }
  popTypeContext(oldIsType);
}

// parse typeof and type imports
export function flowStartParseImportSpecifiers() {
  if (match(tt._typeof) || isContextual(ContextualKeyword._type)) {
    const lh = lookaheadTypeAndKeyword();
    if (isMaybeDefaultImport(lh) || lh.type === tt.braceL || lh.type === tt.star) {
      next();
    }
  }
}

// parse import-type/typeof shorthand
export function flowParseImportSpecifier() {
  const isTypeKeyword =
    state.contextualKeyword === ContextualKeyword._type || state.type === tt._typeof;
  if (isTypeKeyword) {
    next();
  } else {
    parseIdentifier();
  }

  if (isContextual(ContextualKeyword._as) && !isLookaheadContextual(ContextualKeyword._as)) {
    parseIdentifier();
    if (isTypeKeyword && !match(tt.name) && !(state.type & TokenType.IS_KEYWORD)) {
      // `import {type as ,` or `import {type as }`
    } else {
      // `import {type as foo`
      parseIdentifier();
    }
  } else {
    if (isTypeKeyword && (match(tt.name) || !!(state.type & TokenType.IS_KEYWORD))) {
      // `import {type foo`
      parseIdentifier();
    }
    if (eatContextual(ContextualKeyword._as)) {
      parseIdentifier();
    }
  }
}

// parse function type parameters - function foo<T>() {}
export function flowStartParseFunctionParams() {
  // Originally this checked if the method is a getter/setter, but if it was, we'd crash soon
  // anyway, so don't try to propagate that information.
  if (match(tt.lessThan)) {
    const oldIsType = pushTypeContext(0);
    flowParseTypeParameterDeclaration();
    popTypeContext(oldIsType);
  }
}

// parse flow type annotations on variable declarator heads - let foo: string = bar
export function flowAfterParseVarHead() {
  if (match(tt.colon)) {
    flowParseTypeAnnotation();
  }
}

// parse the return type of an async arrow function - let foo = (async (): number => {});
export function flowStartParseAsyncArrowFromCallExpression() {
  if (match(tt.colon)) {
    const oldNoAnonFunctionType = state.noAnonFunctionType;
    state.noAnonFunctionType = true;
    flowParseTypeAnnotation();
    state.noAnonFunctionType = oldNoAnonFunctionType;
  }
}

// We need to support type parameter declarations for arrow functions. This
// is tricky. There are three situations we need to handle
//
// 1. This is either JSX or an arrow function. We'll try JSX first. If that
//    fails, we'll try an arrow function. If that fails, we'll throw the JSX
//    error.
// 2. This is an arrow function. We'll parse the type parameter declaration,
//    parse the rest, make sure the rest is an arrow function, and go from
//    there
// 3. This is neither. Just call the super method
export function flowParseMaybeAssign(noIn, isWithinParens) {
  if (match(tt.lessThan)) {
    const snapshot = state.snapshot();
    let wasArrow = baseParseMaybeAssign(noIn, isWithinParens);
    if (state.error) {
      state.restoreFromSnapshot(snapshot);
      state.type = tt.typeParameterStart;
    } else {
      return wasArrow;
    }

    const oldIsType = pushTypeContext(0);
    flowParseTypeParameterDeclaration();
    popTypeContext(oldIsType);
    wasArrow = baseParseMaybeAssign(noIn, isWithinParens);
    if (wasArrow) {
      return true;
    }
    unexpected();
  }

  return baseParseMaybeAssign(noIn, isWithinParens);
}

// handle return types for arrow functions
export function flowParseArrow() {
  if (match(tt.colon)) {
    const oldIsType = pushTypeContext(0);
    const snapshot = state.snapshot();

    const oldNoAnonFunctionType = state.noAnonFunctionType;
    state.noAnonFunctionType = true;
    flowParseTypeAndPredicateInitialiser();
    state.noAnonFunctionType = oldNoAnonFunctionType;

    if (canInsertSemicolon()) unexpected();
    if (!match(tt.arrow)) unexpected();

    if (state.error) {
      state.restoreFromSnapshot(snapshot);
    }
    popTypeContext(oldIsType);
  }
  return eat(tt.arrow);
}

export function flowParseSubscripts(startTokenIndex, noCalls = false) {
  if (
    state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async &&
    match(tt.lessThan)
  ) {
    const snapshot = state.snapshot();
    const wasArrow = parseAsyncArrowWithTypeParameters();
    if (wasArrow && !state.error) {
      return;
    }
    state.restoreFromSnapshot(snapshot);
  }

  baseParseSubscripts(startTokenIndex, noCalls);
}

// Returns true if there was an arrow function here.
function parseAsyncArrowWithTypeParameters() {
  state.scopeDepth++;
  const startTokenIndex = state.tokens.length;
  parseFunctionParams();
  if (!parseArrow()) {
    return false;
  }
  parseArrowExpression(startTokenIndex);
  return true;
}

function flowParseEnumDeclaration() {
  expectContextual(ContextualKeyword._enum);
  state.tokens[state.tokens.length - 1].type = tt._enum;
  parseIdentifier();
  flowParseEnumBody();
}

function flowParseEnumBody() {
  if (eatContextual(ContextualKeyword._of)) {
    next();
  }
  expect(tt.braceL);
  flowParseEnumMembers();
  expect(tt.braceR);
}

function flowParseEnumMembers() {
  while (!match(tt.braceR) && !state.error) {
    if (eat(tt.ellipsis)) {
      break;
    }
    flowParseEnumMember();
    if (!match(tt.braceR)) {
      expect(tt.comma);
    }
  }
}

function flowParseEnumMember() {
  parseIdentifier();
  if (eat(tt.eq)) {
    // Flow enum values are always just one token (a string, number, or boolean literal).
    next();
  }
}
